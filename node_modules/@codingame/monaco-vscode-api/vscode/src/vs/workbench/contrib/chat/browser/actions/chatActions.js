
import { __decorate, __param } from '../../../../../../../../external/tslib/tslib.es6.js';
import { isAncestorOfActiveElement } from '../../../../../base/browser/dom.js';
import { mainWindow } from '../../../../../base/browser/window.js';
import { toAction } from '../../../../../base/common/actions.js';
import { coalesce } from '../../../../../base/common/arrays.js';
import { timeout } from '../../../../../base/common/async.js';
import { CancellationTokenSource } from '../../../../../base/common/cancellation.js';
import { Codicon } from '../../../../../base/common/codicons.js';
import { fromNowByDay, safeIntl } from '../../../../../base/common/date.js';
import { Event } from '../../../../../base/common/event.js';
import { MarkdownString } from '../../../../../base/common/htmlContent.js';
import { KeyMod as KeyMod$1, KeyCode } from '../../../../../base/common/keyCodes.js';
import { DisposableStore, Disposable, markAsSingleton } from '../../../../../base/common/lifecycle.js';
import { MarshalledId } from '../../../../../base/common/marshallingIds.js';
import { language } from '../../../../../base/common/platform.js';
import { basename, isEqual } from '../../../../../base/common/resources.js';
import { ThemeIcon } from '../../../../../base/common/themables.js';
import { hasKey } from '../../../../../base/common/types.js';
import { URI } from '../../../../../base/common/uri.js';
import { EditorAction2 } from '../../../../../editor/browser/editorExtensions.js';
import { localize2, localize } from '../../../../../nls.js';
import { IActionViewItemService } from '../../../../../platform/actions/browser/actionViewItemService.service.js';
import { DropdownWithPrimaryActionViewItem } from '../../../../../platform/actions/browser/dropdownWithPrimaryActionViewItem.js';
import { getContextMenuActions } from '../../../../../platform/actions/browser/menuEntryActionViewItem.js';
import { MenuId, Action2, registerAction2, MenuRegistry, SubmenuItemAction, MenuItemAction } from '../../../../../platform/actions/common/actions.js';
import { IMenuService } from '../../../../../platform/actions/common/actions.service.js';
import { ICommandService } from '../../../../../platform/commands/common/commands.service.js';
import { IConfigurationService } from '../../../../../platform/configuration/common/configuration.service.js';
import { ContextKeyExpr } from '../../../../../platform/contextkey/common/contextkey.js';
import { IContextKeyService } from '../../../../../platform/contextkey/common/contextkey.service.js';
import { IsWindowsContext, IsLinuxContext } from '../../../../../platform/contextkey/common/contextkeys.js';
import { IDialogService } from '../../../../../platform/dialogs/common/dialogs.service.js';
import { IFileService } from '../../../../../platform/files/common/files.service.js';
import { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';
import { KeybindingWeight } from '../../../../../platform/keybinding/common/keybindingsRegistry.js';
import { INotificationService } from '../../../../../platform/notification/common/notification.service.js';
import { IOpenerService } from '../../../../../platform/opener/common/opener.service.js';
import product from '../../../../../platform/product/common/product.js';
import { IQuickInputService } from '../../../../../platform/quickinput/common/quickInput.service.js';
import { ITelemetryService } from '../../../../../platform/telemetry/common/telemetry.service.js';
import { ToggleTitleBarConfigAction } from '../../../../browser/parts/titlebar/titlebarActions.js';
import { ActiveEditorContext, IsCompactTitleBarContext } from '../../../../common/contextkeys.js';
import { ViewContainerLocation } from '../../../../common/views.js';
import { IViewDescriptorService } from '../../../../common/views.service.js';
import { ChatEntitlement } from '../../../../services/chat/common/chatEntitlementService.js';
import { IChatEntitlementService } from '../../../../services/chat/common/chatEntitlementService.service.js';
import { GroupDirection } from '../../../../services/editor/common/editorGroupsService.js';
import { IEditorGroupsService } from '../../../../services/editor/common/editorGroupsService.service.js';
import { ACTIVE_GROUP, AUX_WINDOW_GROUP } from '../../../../services/editor/common/editorService.js';
import { IEditorService } from '../../../../services/editor/common/editorService.service.js';
import { IHostService } from '../../../../services/host/browser/host.service.js';
import { Parts } from '../../../../services/layout/browser/layoutService.js';
import { IWorkbenchLayoutService } from '../../../../services/layout/browser/layoutService.service.js';
import { IPreferencesService } from '../../../../services/preferences/common/preferences.service.js';
import { IViewsService } from '../../../../services/views/common/viewsService.service.js';
import { EXTENSIONS_CATEGORY } from '../../../extensions/common/extensions.js';
import { IExtensionsWorkbenchService } from '../../../extensions/common/extensions.service.js';
import { SCMHistoryItemChangeRangeContentProvider } from '../../../scm/browser/scmHistoryChatContext.js';
import { ISCMService } from '../../../scm/common/scm.service.js';
import { IChatAgentService } from '../../common/chatAgents.service.js';
import { ChatContextKeys } from '../../common/chatContextKeys.js';
import { ModifiedFileEntryState } from '../../common/chatEditingService.js';
import { ChatMode } from '../../common/chatModes.js';
import { IChatModeService } from '../../common/chatModes.service.js';
import { ResponseModelState } from '../../common/chatService.js';
import { IChatService } from '../../common/chatService.service.js';
import { localChatSessionType } from '../../common/chatSessionsService.js';
import { IChatSessionsService } from '../../common/chatSessionsService.service.js';
import { isRequestVM } from '../../common/chatViewModel.js';
import { IChatWidgetHistoryService } from '../../common/chatWidgetHistoryService.service.js';
import { ChatAgentLocation, ChatConfiguration, LEGACY_AGENT_SESSIONS_VIEW_ID, ChatModeKind } from '../../common/constants.js';
import { ILanguageModelsService } from '../../common/languageModels.service.js';
import { CopilotUsageExtensionFeatureId } from '../../common/languageModelStats.js';
import { ILanguageModelToolsConfirmationService } from '../../common/languageModelToolsConfirmationService.service.js';
import { ILanguageModelToolsService } from '../../common/languageModelToolsService.service.js';
import { ChatViewId, ChatViewPaneTarget } from '../chat.js';
import { IChatWidgetService } from '../chat.service.js';
import { ChatEditorInput, showClearEditingSessionConfirmation } from '../chatEditorInput.js';
import { convertBufferToScreenshotVariable } from '../contrib/screenshot.js';
import { clearChatEditor } from './chatClear.js';

const CHAT_CATEGORY = ( localize2(4599, 'Chat'));
const ACTION_ID_NEW_CHAT = `workbench.action.chat.newChat`;
const ACTION_ID_NEW_EDIT_SESSION = `workbench.action.chat.newEditSession`;
const ACTION_ID_OPEN_CHAT = 'workbench.action.openChat';
const CHAT_OPEN_ACTION_ID = 'workbench.action.chat.open';
const CHAT_SETUP_ACTION_ID = 'workbench.action.chat.triggerSetup';
const CHAT_SETUP_SUPPORT_ANONYMOUS_ACTION_ID = 'workbench.action.chat.triggerSetupSupportAnonymousAction';
const TOGGLE_CHAT_ACTION_ID = 'workbench.action.chat.toggle';
const CHAT_CLEAR_HISTORY_ACTION_ID = 'workbench.action.chat.clearHistory';
const CHAT_CONFIG_MENU_ID = ( new MenuId('workbench.chat.menu.config'));
const OPEN_CHAT_QUOTA_EXCEEDED_DIALOG = 'workbench.action.chat.openQuotaExceededDialog';
class OpenChatGlobalAction extends Action2 {
    constructor(overrides, mode) {
        super({
            ...overrides,
            icon: Codicon.chatSparkle,
            f1: true,
            category: CHAT_CATEGORY,
            precondition: ( ContextKeyExpr.and(( ChatContextKeys.Setup.hidden.negate()), ( ChatContextKeys.Setup.disabled.negate())))
        });
        this.mode = mode;
    }
    async run(accessor, opts) {
        opts = typeof opts === 'string' ? { query: opts } : opts;
        const chatService = accessor.get(IChatService);
        const widgetService = accessor.get(IChatWidgetService);
        const toolsService = accessor.get(ILanguageModelToolsService);
        const hostService = accessor.get(IHostService);
        const chatAgentService = accessor.get(IChatAgentService);
        const instaService = accessor.get(IInstantiationService);
        const commandService = accessor.get(ICommandService);
        const chatModeService = accessor.get(IChatModeService);
        const fileService = accessor.get(IFileService);
        const languageModelService = accessor.get(ILanguageModelsService);
        const scmService = accessor.get(ISCMService);
        let chatWidget = widgetService.lastFocusedWidget;
        if (!this.mode || !chatWidget || !isAncestorOfActiveElement(chatWidget.domNode)) {
            chatWidget = await widgetService.revealWidget();
        }
        if (!chatWidget) {
            return;
        }
        const switchToMode = (opts?.mode ? chatModeService.findModeByName(opts?.mode) : undefined) ?? this.mode;
        if (switchToMode) {
            await this.handleSwitchToMode(switchToMode, chatWidget, instaService, commandService);
        }
        if (opts?.modelSelector) {
            const ids = await languageModelService.selectLanguageModels(opts.modelSelector, false);
            const id = ids.sort().at(0);
            if (!id) {
                throw ( new Error(
                    `No language models found matching selector: ${JSON.stringify(opts.modelSelector)}.`
                ));
            }
            const model = languageModelService.lookupLanguageModel(id);
            if (!model) {
                throw ( new Error(`Language model not loaded: ${id}.`));
            }
            chatWidget.input.setCurrentLanguageModel({ metadata: model, identifier: id });
        }
        if (opts?.previousRequests?.length && chatWidget.viewModel) {
            for (const { request, response } of opts.previousRequests) {
                chatService.addCompleteRequest(chatWidget.viewModel.sessionResource, request, undefined, 0, { message: response });
            }
        }
        if (opts?.attachScreenshot) {
            const screenshot = await hostService.getScreenshot();
            if (screenshot) {
                chatWidget.attachmentModel.addContext(convertBufferToScreenshotVariable(screenshot));
            }
        }
        if (opts?.attachFiles) {
            for (const file of opts.attachFiles) {
                const uri = file instanceof URI ? file : file.uri;
                const range = file instanceof URI ? undefined : file.range;
                if (await fileService.exists(uri)) {
                    chatWidget.attachmentModel.addFile(uri, range);
                }
            }
        }
        if (opts?.attachHistoryItemChanges) {
            for (const historyItemChange of opts.attachHistoryItemChanges) {
                const repository = scmService.getRepository(URI.file(historyItemChange.uri.path));
                const historyProvider = repository?.provider.historyProvider.get();
                if (!historyProvider) {
                    continue;
                }
                const historyItem = await historyProvider.resolveHistoryItem(historyItemChange.historyItemId);
                if (!historyItem) {
                    continue;
                }
                chatWidget.attachmentModel.addContext({
                    id: ( historyItemChange.uri.toString()),
                    name: `${basename(historyItemChange.uri)}`,
                    value: historyItemChange.uri,
                    historyItem: historyItem,
                    kind: 'scmHistoryItemChange'
                });
            }
        }
        if (opts?.attachHistoryItemChangeRanges) {
            for (const historyItemChangeRange of opts.attachHistoryItemChangeRanges) {
                const repository = scmService.getRepository(URI.file(historyItemChangeRange.end.uri.path));
                const historyProvider = repository?.provider.historyProvider.get();
                if (!repository || !historyProvider) {
                    continue;
                }
                const [historyItemStart, historyItemEnd] = await Promise.all([
                    historyProvider.resolveHistoryItem(historyItemChangeRange.start.historyItemId),
                    historyProvider.resolveHistoryItem(historyItemChangeRange.end.historyItemId),
                ]);
                if (!historyItemStart || !historyItemEnd) {
                    continue;
                }
                const uri = historyItemChangeRange.end.uri.with({
                    scheme: SCMHistoryItemChangeRangeContentProvider.scheme,
                    query: JSON.stringify({
                        repositoryId: repository.id,
                        start: historyItemStart.id,
                        end: historyItemChangeRange.end.historyItemId
                    })
                });
                chatWidget.attachmentModel.addContext({
                    id: ( uri.toString()),
                    name: `${basename(uri)}`,
                    value: uri,
                    historyItemChangeStart: {
                        uri: historyItemChangeRange.start.uri,
                        historyItem: historyItemStart
                    },
                    historyItemChangeEnd: {
                        uri: historyItemChangeRange.end.uri,
                        historyItem: {
                            ...historyItemEnd,
                            displayId: historyItemChangeRange.end.historyItemId
                        }
                    },
                    kind: 'scmHistoryItemChangeRange'
                });
            }
        }
        let resp;
        if (opts?.query) {
            chatWidget.setInput(opts.query);
            if (!opts.isPartialQuery) {
                if (!chatWidget.viewModel) {
                    await Event.toPromise(chatWidget.onDidChangeViewModel);
                }
                await waitForDefaultAgent(chatAgentService, chatWidget.input.currentModeKind);
                resp = chatWidget.acceptInput();
            }
        }
        if (opts?.toolIds && opts.toolIds.length > 0) {
            for (const toolId of opts.toolIds) {
                const tool = toolsService.getTool(toolId);
                if (tool) {
                    chatWidget.attachmentModel.addContext({
                        id: tool.id,
                        name: tool.displayName,
                        fullName: tool.displayName,
                        value: undefined,
                        icon: ThemeIcon.isThemeIcon(tool.icon) ? tool.icon : undefined,
                        kind: 'tool'
                    });
                }
            }
        }
        chatWidget.focusInput();
        if (opts?.blockOnResponse) {
            const response = await resp;
            if (response) {
                await ( new Promise(resolve => {
                    const d = response.onDidChange(async () => {
                        if (response.isComplete || response.isPendingConfirmation.get()) {
                            d.dispose();
                            resolve();
                        }
                    });
                }));
                return { ...response.result, type: response.isPendingConfirmation.get() ? 'confirmation' : undefined };
            }
        }
        return undefined;
    }
    async handleSwitchToMode(switchToMode, chatWidget, instaService, commandService) {
        const currentMode = chatWidget.input.currentModeKind;
        if (switchToMode) {
            const model = chatWidget.viewModel?.model;
            const chatModeCheck = model ? await instaService.invokeFunction(handleModeSwitch, currentMode, switchToMode.kind, model.getRequests().length, model) : { needToClearSession: false };
            if (!chatModeCheck) {
                return;
            }
            chatWidget.input.setChatMode(switchToMode.id);
            if (chatModeCheck.needToClearSession) {
                await commandService.executeCommand(ACTION_ID_NEW_CHAT);
            }
        }
    }
}
async function waitForDefaultAgent(chatAgentService, mode) {
    const defaultAgent = chatAgentService.getDefaultAgent(ChatAgentLocation.Chat, mode);
    if (defaultAgent) {
        return;
    }
    await Promise.race([
        Event.toPromise(Event.filter(chatAgentService.onDidChangeAgents, () => {
            const defaultAgent = chatAgentService.getDefaultAgent(ChatAgentLocation.Chat, mode);
            return Boolean(defaultAgent);
        })),
        timeout(60_000).then(() => { throw ( new Error('Timed out waiting for default agent')); })
    ]);
}
class PrimaryOpenChatGlobalAction extends OpenChatGlobalAction {
    constructor() {
        super({
            id: CHAT_OPEN_ACTION_ID,
            title: ( localize2(4600, "Open Chat")),
            keybinding: {
                weight: KeybindingWeight.WorkbenchContrib,
                primary: KeyMod$1.CtrlCmd | KeyMod$1.Alt | KeyCode.KeyI,
                mac: {
                    primary: KeyMod$1.CtrlCmd | KeyMod$1.WinCtrl | KeyCode.KeyI
                }
            },
            menu: [{
                    id: MenuId.ChatTitleBarMenu,
                    group: 'a_open',
                    order: 1
                }]
        });
    }
}
function getOpenChatActionIdForMode(mode) {
    return `workbench.action.chat.open${mode.name.get()}`;
}
class ModeOpenChatGlobalAction extends OpenChatGlobalAction {
    constructor(mode, keybinding) {
        super({
            id: getOpenChatActionIdForMode(mode),
            title: ( localize2(4601, "Open Chat ({0})", mode.label.get())),
            keybinding
        }, mode);
    }
}
function registerChatActions() {
    registerAction2(PrimaryOpenChatGlobalAction);
    registerAction2(class extends ModeOpenChatGlobalAction {
        constructor() { super(ChatMode.Ask); }
    });
    registerAction2(class extends ModeOpenChatGlobalAction {
        constructor() {
            super(ChatMode.Agent, {
                when: ( ContextKeyExpr.has(`config.${ChatConfiguration.AgentEnabled}`)),
                weight: KeybindingWeight.WorkbenchContrib,
                primary: KeyMod$1.CtrlCmd | KeyMod$1.Shift | KeyCode.KeyI,
                linux: {
                    primary: KeyMod$1.CtrlCmd | KeyMod$1.Alt | KeyMod$1.Shift | KeyCode.KeyI
                }
            });
        }
    });
    registerAction2(class extends ModeOpenChatGlobalAction {
        constructor() { super(ChatMode.Edit); }
    });
    registerAction2(class ToggleChatAction extends Action2 {
        constructor() {
            super({
                id: TOGGLE_CHAT_ACTION_ID,
                title: ( localize2(4602, "Toggle Chat")),
                category: CHAT_CATEGORY
            });
        }
        async run(accessor) {
            const layoutService = accessor.get(IWorkbenchLayoutService);
            const viewsService = accessor.get(IViewsService);
            const viewDescriptorService = accessor.get(IViewDescriptorService);
            const widgetService = accessor.get(IChatWidgetService);
            const chatLocation = viewDescriptorService.getViewLocationById(ChatViewId);
            if (viewsService.isViewVisible(ChatViewId)) {
                this.updatePartVisibility(layoutService, chatLocation, false);
            }
            else {
                this.updatePartVisibility(layoutService, chatLocation, true);
                (await widgetService.revealWidget())?.focusInput();
            }
        }
        updatePartVisibility(layoutService, location, visible) {
            let part;
            switch (location) {
                case ViewContainerLocation.Panel:
                    part = Parts.PANEL_PART;
                    break;
                case ViewContainerLocation.Sidebar:
                    part = Parts.SIDEBAR_PART;
                    break;
                case ViewContainerLocation.AuxiliaryBar:
                    part = Parts.AUXILIARYBAR_PART;
                    break;
            }
            if (part) {
                layoutService.setPartHidden(!visible, part);
            }
        }
    });
    registerAction2(class ChatHistoryAction extends Action2 {
        constructor() {
            super({
                id: `workbench.action.chat.history`,
                title: ( localize2(4603, "Show Chats...")),
                menu: [
                    {
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('view', ChatViewId)), ( ContextKeyExpr.equals(`config.${ChatConfiguration.ChatViewSessionsEnabled}`, false)))),
                        group: 'navigation',
                        order: 2
                    },
                    {
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('view', ChatViewId)), ( ContextKeyExpr.equals(`config.${ChatConfiguration.ChatViewSessionsEnabled}`, true)))),
                        group: '2_history',
                        order: 1
                    },
                    {
                        id: MenuId.EditorTitle,
                        when: ( ActiveEditorContext.isEqualTo(ChatEditorInput.EditorID)),
                    }
                ],
                category: CHAT_CATEGORY,
                icon: Codicon.history,
                f1: true,
                precondition: ChatContextKeys.enabled
            });
            this.showLegacyPicker = async (chatService, quickInputService, commandService, editorService, chatWidgetService, view) => {
                const clearChatHistoryButton = {
                    iconClass: ThemeIcon.asClassName(Codicon.clearAll),
                    tooltip: ( localize(4604, "Clear All Workspace Chats")),
                };
                const openInEditorButton = {
                    iconClass: ThemeIcon.asClassName(Codicon.file),
                    tooltip: ( localize(4605, "Open in Editor")),
                };
                const deleteButton = {
                    iconClass: ThemeIcon.asClassName(Codicon.x),
                    tooltip: ( localize(4606, "Delete")),
                };
                const renameButton = {
                    iconClass: ThemeIcon.asClassName(Codicon.pencil),
                    tooltip: ( localize(4607, "Rename")),
                };
                const getPicks = async () => {
                    const items = await chatService.getLocalSessionHistory();
                    items.sort((a, b) => (b.lastMessageDate ?? 0) - (a.lastMessageDate ?? 0));
                    let lastDate = undefined;
                    const picks = items.flatMap((i) => {
                        const timeAgoStr = fromNowByDay(i.lastMessageDate, true, true);
                        const separator = timeAgoStr !== lastDate ? {
                            type: 'separator', label: timeAgoStr,
                        } : undefined;
                        lastDate = timeAgoStr;
                        return [
                            separator,
                            {
                                label: i.title,
                                description: i.isActive ? `(${( localize(4608, 'current'))})` : '',
                                chat: i,
                                buttons: i.isActive ? [renameButton] : [
                                    renameButton,
                                    openInEditorButton,
                                    deleteButton,
                                ]
                            }
                        ];
                    });
                    return coalesce(picks);
                };
                const store = ( new DisposableStore());
                const picker = store.add(quickInputService.createQuickPick({ useSeparators: true }));
                picker.title = ( localize(4609, "Workspace Chat History"));
                picker.placeholder = ( localize(4610, "Switch to chat"));
                picker.buttons = [clearChatHistoryButton];
                const picks = await getPicks();
                picker.items = picks;
                store.add(picker.onDidTriggerButton(async (button) => {
                    if (button === clearChatHistoryButton) {
                        await commandService.executeCommand(CHAT_CLEAR_HISTORY_ACTION_ID);
                    }
                }));
                store.add(picker.onDidTriggerItemButton(async (context) => {
                    if (context.button === openInEditorButton) {
                        chatWidgetService.openSession(context.item.chat.sessionResource, ACTIVE_GROUP, { pinned: true });
                        picker.hide();
                    }
                    else if (context.button === deleteButton) {
                        chatService.removeHistoryEntry(context.item.chat.sessionResource);
                        picker.items = await getPicks();
                    }
                    else if (context.button === renameButton) {
                        const title = await quickInputService.input({ title: ( localize(4611, "New chat title")), value: context.item.chat.title });
                        if (title) {
                            chatService.setChatSessionTitle(context.item.chat.sessionResource, title);
                        }
                        await this.showLegacyPicker(chatService, quickInputService, commandService, editorService, chatWidgetService, view);
                    }
                }));
                store.add(picker.onDidAccept(async () => {
                    try {
                        const item = picker.selectedItems[0];
                        await chatWidgetService.openSession(item.chat.sessionResource, ChatViewPaneTarget);
                    }
                    finally {
                        picker.hide();
                    }
                }));
                store.add(picker.onDidHide(() => store.dispose()));
                picker.show();
            };
        }
        async showIntegratedPicker(chatService, quickInputService, commandService, editorService, chatWidgetService, view, chatSessionsService, contextKeyService, menuService, showAllChats = false, showAllAgents = false) {
            const clearChatHistoryButton = {
                iconClass: ThemeIcon.asClassName(Codicon.clearAll),
                tooltip: ( localize(4604, "Clear All Workspace Chats")),
            };
            const openInEditorButton = {
                iconClass: ThemeIcon.asClassName(Codicon.file),
                tooltip: ( localize(4605, "Open in Editor")),
            };
            const deleteButton = {
                iconClass: ThemeIcon.asClassName(Codicon.x),
                tooltip: ( localize(4606, "Delete")),
            };
            const renameButton = {
                iconClass: ThemeIcon.asClassName(Codicon.pencil),
                tooltip: ( localize(4607, "Rename")),
            };
            function isChatPickerItem(item) {
                return hasKey(item, { chat: true });
            }
            function isCodingAgentPickerItem(item) {
                return isChatPickerItem(item) && hasKey(item, { session: true });
            }
            const showMorePick = {
                label: ( localize(4612, 'Show more...')),
            };
            const showMoreAgentsPick = {
                label: ( localize(4613, 'Show more...')),
            };
            const getPicks = async (showAllChats = false, showAllAgents = false) => {
                const cachedItems = await chatService.getLocalSessionHistory();
                cachedItems.sort((a, b) => (b.lastMessageDate ?? 0) - (a.lastMessageDate ?? 0));
                const allFastPickItems = ( cachedItems.map((i) => {
                    const timeAgoStr = fromNowByDay(i.lastMessageDate, true, true);
                    const currentLabel = i.isActive ? ( localize(4608, 'current')) : '';
                    const description = currentLabel ? `${timeAgoStr} â€¢ ${currentLabel}` : timeAgoStr;
                    return {
                        label: i.title,
                        description: description,
                        chat: i,
                        buttons: i.isActive ? [renameButton] : [
                            renameButton,
                            openInEditorButton,
                            deleteButton,
                        ]
                    };
                }));
                const fastPickItems = showAllChats ? allFastPickItems : allFastPickItems.slice(0, 5);
                const fastPicks = [];
                if (fastPickItems.length > 0) {
                    fastPicks.push({
                        type: 'separator',
                        label: ( localize(4614, 'Recent Chats')),
                    });
                    fastPicks.push(...fastPickItems);
                    if (!showAllChats && allFastPickItems.length > 5) {
                        fastPicks.push(showMorePick);
                    }
                }
                const slowPicks = (async function* () {
                    try {
                        const agentPicks = [];
                        const cancellationToken = ( new CancellationTokenSource());
                        try {
                            const providerNSessions = await chatSessionsService.getAllChatSessionItems(cancellationToken.token);
                            for (const { chatSessionType, items } of providerNSessions) {
                                for (const session of items) {
                                    const ckey = contextKeyService.createKey('chatSessionType', chatSessionType);
                                    const actions = menuService.getMenuActions(MenuId.AgentSessionsContext, contextKeyService);
                                    const { primary } = getContextMenuActions(actions, 'inline');
                                    ckey.reset();
                                    const buttons = ( primary.map(action => ({
                                        id: action.id,
                                        tooltip: action.tooltip,
                                        iconClass: action.class || ThemeIcon.asClassName(Codicon.symbolClass),
                                    })));
                                    const agentPick = {
                                        label: session.label,
                                        description: chatSessionType,
                                        session: session,
                                        chat: {
                                            sessionResource: session.resource,
                                            title: session.label,
                                            isActive: false,
                                            lastMessageDate: 0,
                                            timing: { startTime: 0 },
                                            lastResponseState: ResponseModelState.Complete
                                        },
                                        buttons,
                                    };
                                    const existingIndex = agentPicks.findIndex(pick => isEqual(pick.chat.sessionResource, session.resource));
                                    if (existingIndex >= 0) {
                                        agentPicks[existingIndex] = agentPick;
                                    }
                                    else {
                                        agentPicks.push(agentPick);
                                    }
                                }
                            }
                            const currentPicks = [];
                            if (agentPicks.length > 0) {
                                currentPicks.push({
                                    type: 'separator',
                                    label: 'Chat Sessions',
                                });
                                const defaultMaxToShow = 5;
                                const maxToShow = showAllAgents ? Number.MAX_SAFE_INTEGER : defaultMaxToShow;
                                currentPicks.push(...agentPicks
                                    .toSorted((a, b) => (b.session.timing.endTime ?? b.session.timing.startTime) - (a.session.timing.endTime ?? a.session.timing.startTime))
                                    .slice(0, maxToShow));
                                if (!showAllAgents && agentPicks.length > defaultMaxToShow) {
                                    currentPicks.push(showMoreAgentsPick);
                                }
                            }
                            yield currentPicks;
                        }
                        finally {
                            cancellationToken.dispose();
                        }
                    }
                    catch (error) {
                        return;
                    }
                })();
                return {
                    fast: coalesce(fastPicks),
                    slow: slowPicks
                };
            };
            const store = ( new DisposableStore());
            const picker = store.add(quickInputService.createQuickPick({ useSeparators: true }));
            picker.title = (showAllChats || showAllAgents) ?
                ( localize(4615, "All Workspace Chat History")) :
                ( localize(4609, "Workspace Chat History"));
            picker.placeholder = ( localize(4610, "Switch to chat"));
            picker.buttons = [clearChatHistoryButton];
            const { fast, slow } = await getPicks(showAllChats, showAllAgents);
            picker.items = fast;
            picker.busy = true;
            (async () => {
                try {
                    for await (const slowPicks of slow) {
                        if (!store.isDisposed) {
                            picker.items = coalesce([...fast, ...slowPicks]);
                        }
                    }
                }
                catch (error) {
                }
                finally {
                    if (!store.isDisposed) {
                        picker.busy = false;
                    }
                }
            })();
            store.add(picker.onDidTriggerButton(async (button) => {
                if (button === clearChatHistoryButton) {
                    await commandService.executeCommand(CHAT_CLEAR_HISTORY_ACTION_ID);
                }
            }));
            store.add(picker.onDidTriggerItemButton(async (context) => {
                if (!isChatPickerItem(context.item)) {
                    return;
                }
                if (context.button === openInEditorButton) {
                    const options = { pinned: true };
                    chatWidgetService.openSession(context.item.chat.sessionResource, ACTIVE_GROUP, options);
                    picker.hide();
                }
                else if (context.button === deleteButton) {
                    chatService.removeHistoryEntry(context.item.chat.sessionResource);
                    const { fast, slow } = await getPicks(showAllChats, showAllAgents);
                    picker.items = fast;
                    picker.busy = true;
                    (async () => {
                        try {
                            for await (const slowPicks of slow) {
                                if (!store.isDisposed) {
                                    picker.items = coalesce([...fast, ...slowPicks]);
                                }
                            }
                        }
                        catch (error) {
                        }
                        finally {
                            if (!store.isDisposed) {
                                picker.busy = false;
                            }
                        }
                    })();
                }
                else if (context.button === renameButton) {
                    const title = await quickInputService.input({ title: ( localize(4611, "New chat title")), value: context.item.chat.title });
                    if (title) {
                        chatService.setChatSessionTitle(context.item.chat.sessionResource, title);
                    }
                    await this.showIntegratedPicker(chatService, quickInputService, commandService, editorService, chatWidgetService, view, chatSessionsService, contextKeyService, menuService, showAllChats, showAllAgents);
                }
                else {
                    const buttonItem = context.button;
                    if (buttonItem.id) {
                        const contextItem = context.item;
                        if (contextItem.session) {
                            commandService.executeCommand(buttonItem.id, {
                                session: contextItem.session,
                                $mid: MarshalledId.ChatSessionContext
                            });
                        }
                        picker.hide();
                    }
                }
            }));
            store.add(picker.onDidAccept(async () => {
                try {
                    const item = picker.selectedItems[0];
                    if (item === showMorePick) {
                        picker.hide();
                        await this.showIntegratedPicker(chatService, quickInputService, commandService, editorService, chatWidgetService, view, chatSessionsService, contextKeyService, menuService, true, showAllAgents);
                        return;
                    }
                    else if (item === showMoreAgentsPick) {
                        picker.hide();
                        await this.showIntegratedPicker(chatService, quickInputService, commandService, editorService, chatWidgetService, view, chatSessionsService, contextKeyService, menuService, showAllChats, true);
                        return;
                    }
                    else if (isCodingAgentPickerItem(item)) {
                        if (item.session) {
                            await this.showChatSessionInEditor(item.session, chatWidgetService);
                        }
                    }
                    else if (isChatPickerItem(item)) {
                        await chatWidgetService.openSession(item.chat.sessionResource, ChatViewPaneTarget);
                    }
                }
                finally {
                    picker.hide();
                }
            }));
            store.add(picker.onDidHide(() => store.dispose()));
            picker.show();
        }
        async run(accessor) {
            const chatService = accessor.get(IChatService);
            const quickInputService = accessor.get(IQuickInputService);
            const viewsService = accessor.get(IViewsService);
            const editorService = accessor.get(IEditorService);
            const chatWidgetService = accessor.get(IChatWidgetService);
            const dialogService = accessor.get(IDialogService);
            const commandService = accessor.get(ICommandService);
            const chatSessionsService = accessor.get(IChatSessionsService);
            const contextKeyService = accessor.get(IContextKeyService);
            const menuService = accessor.get(IMenuService);
            const view = await viewsService.openView(ChatViewId);
            if (!view?.widget.viewModel) {
                return;
            }
            const phrase = ( localize(4616, "Switching chats will end your current edit session."));
            if (!(await handleCurrentEditingSession(view.widget.viewModel.model, phrase, dialogService))) {
                return;
            }
            const allProviders = chatSessionsService.getAllChatSessionItemProviders();
            const hasNonLocalProviders = ( allProviders.some(provider => provider.chatSessionType !== localChatSessionType));
            if (hasNonLocalProviders) {
                await this.showIntegratedPicker(chatService, quickInputService, commandService, editorService, chatWidgetService, view, chatSessionsService, contextKeyService, menuService);
            }
            else {
                await this.showLegacyPicker(chatService, quickInputService, commandService, editorService, chatWidgetService, view);
            }
        }
        async showChatSessionInEditor(session, chatWidgetService) {
            await chatWidgetService.openSession(session.resource, undefined, {});
        }
    });
    registerAction2(class NewChatEditorAction extends Action2 {
        constructor() {
            super({
                id: ACTION_ID_OPEN_CHAT,
                title: ( localize2(4617, "New Chat Editor")),
                icon: Codicon.plus,
                f1: true,
                category: CHAT_CATEGORY,
                precondition: ChatContextKeys.enabled,
                keybinding: {
                    weight: KeybindingWeight.WorkbenchContrib,
                    primary: KeyMod$1.CtrlCmd | KeyCode.KeyN,
                    when: ( ContextKeyExpr.and(ChatContextKeys.inChatSession, ChatContextKeys.inChatEditor))
                },
                menu: [{
                        id: MenuId.ChatTitleBarMenu,
                        group: 'b_new',
                        order: 0
                    }, {
                        id: MenuId.ChatNewMenu,
                        group: '2_new',
                        order: 2
                    }, {
                        id: MenuId.EditorTitle,
                        group: 'navigation',
                        when: ( ContextKeyExpr.and(( ActiveEditorContext.isEqualTo(ChatEditorInput.EditorID)), ( ChatContextKeys.lockedToCodingAgent.negate()))),
                        order: 1
                    }],
            });
        }
        async run(accessor) {
            const widgetService = accessor.get(IChatWidgetService);
            await widgetService.openSession(ChatEditorInput.getNewEditorUri(), undefined, { pinned: true });
        }
    });
    registerAction2(class NewChatWindowAction extends Action2 {
        constructor() {
            super({
                id: `workbench.action.newChatWindow`,
                title: ( localize2(4618, "New Chat Window")),
                f1: true,
                category: CHAT_CATEGORY,
                precondition: ChatContextKeys.enabled,
                menu: [{
                        id: MenuId.ChatTitleBarMenu,
                        group: 'b_new',
                        order: 1
                    }, {
                        id: MenuId.ChatNewMenu,
                        group: '2_new',
                        order: 3
                    }]
            });
        }
        async run(accessor) {
            const widgetService = accessor.get(IChatWidgetService);
            await widgetService.openSession(ChatEditorInput.getNewEditorUri(), AUX_WINDOW_GROUP, { pinned: true, auxiliary: { compact: true, bounds: { width: 640, height: 640 } } });
        }
    });
    registerAction2(class OpenChatEditorInNewWindowAction extends Action2 {
        constructor() {
            super({
                id: `workbench.action.chat.newChatInNewWindow`,
                title: ( localize2(4619, 'Open New Chat in New Window')),
                f1: false,
                category: CHAT_CATEGORY,
                precondition: ChatContextKeys.enabled,
                menu: {
                    id: MenuId.ViewTitle,
                    group: 'submenu',
                    order: 1,
                    when: ( ContextKeyExpr.equals('view', `${LEGACY_AGENT_SESSIONS_VIEW_ID}.local`)),
                }
            });
        }
        async run(accessor) {
            const widgetService = accessor.get(IChatWidgetService);
            await widgetService.openSession(ChatEditorInput.getNewEditorUri(), AUX_WINDOW_GROUP, {
                pinned: true,
                auxiliary: { compact: true, bounds: { width: 800, height: 640 } }
            });
        }
    });
    registerAction2(class NewChatInSideBarAction extends Action2 {
        constructor() {
            super({
                id: `workbench.action.chat.newChatInSideBar`,
                title: ( localize2(4620, 'Open New Chat in Side Bar')),
                f1: false,
                category: CHAT_CATEGORY,
                precondition: ChatContextKeys.enabled,
                menu: {
                    id: MenuId.ViewTitle,
                    group: 'submenu',
                    order: 1,
                    when: ( ContextKeyExpr.equals('view', `${LEGACY_AGENT_SESSIONS_VIEW_ID}.local`)),
                }
            });
        }
        async run(accessor) {
            const widgetService = accessor.get(IChatWidgetService);
            const chatWidget = await widgetService.revealWidget();
            if (chatWidget) {
                await chatWidget.clear();
                chatWidget.attachmentModel.clear(true);
                chatWidget.input.relatedFiles?.clear();
                chatWidget.focusInput();
            }
        }
    });
    registerAction2(class OpenChatInNewEditorGroupAction extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chat.openNewChatToTheSide',
                title: ( localize2(4621, "Open New Chat Editor to the Side")),
                category: CHAT_CATEGORY,
                precondition: ChatContextKeys.enabled,
                f1: false,
                menu: {
                    id: MenuId.ViewTitle,
                    group: 'submenu',
                    order: 1,
                    when: ( ContextKeyExpr.equals('view', `${LEGACY_AGENT_SESSIONS_VIEW_ID}.local`)),
                }
            });
        }
        async run(accessor, ...args) {
            const widgetService = accessor.get(IChatWidgetService);
            const editorGroupService = accessor.get(IEditorGroupsService);
            const newGroup = editorGroupService.addGroup(editorGroupService.activeGroup, GroupDirection.RIGHT);
            editorGroupService.activateGroup(newGroup);
            await widgetService.openSession(ChatEditorInput.getNewEditorUri(), newGroup.id, { pinned: true });
        }
    });
    registerAction2(class ClearChatInputHistoryAction extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chat.clearInputHistory',
                title: ( localize2(4622, "Clear Input History")),
                precondition: ChatContextKeys.enabled,
                category: CHAT_CATEGORY,
                f1: true,
            });
        }
        async run(accessor, ...args) {
            const historyService = accessor.get(IChatWidgetHistoryService);
            historyService.clearHistory();
        }
    });
    registerAction2(class ClearChatHistoryAction extends Action2 {
        constructor() {
            super({
                id: CHAT_CLEAR_HISTORY_ACTION_ID,
                title: ( localize2(4623, "Clear All Workspace Chats")),
                precondition: ChatContextKeys.enabled,
                category: CHAT_CATEGORY,
                f1: true,
            });
        }
        async run(accessor, ...args) {
            const editorGroupsService = accessor.get(IEditorGroupsService);
            const chatService = accessor.get(IChatService);
            const instantiationService = accessor.get(IInstantiationService);
            const widgetService = accessor.get(IChatWidgetService);
            await chatService.clearAllHistoryEntries();
            await Promise.all(( widgetService.getAllWidgets().map(widget => widget.clear())));
            editorGroupsService.groups.forEach(group => {
                group.editors.forEach(editor => {
                    if (editor instanceof ChatEditorInput) {
                        instantiationService.invokeFunction(clearChatEditor, editor);
                    }
                });
            });
        }
    });
    registerAction2(class FocusChatAction extends EditorAction2 {
        constructor() {
            super({
                id: 'chat.action.focus',
                title: ( localize2(4624, 'Focus Chat List')),
                precondition: ( ContextKeyExpr.and(ChatContextKeys.inChatInput)),
                category: CHAT_CATEGORY,
                keybinding: [
                    {
                        when: ( ContextKeyExpr.and(ChatContextKeys.inputCursorAtTop, ( ChatContextKeys.inQuickChat.negate()))),
                        primary: KeyMod$1.CtrlCmd | KeyCode.UpArrow,
                        weight: KeybindingWeight.EditorContrib,
                    },
                    {
                        when: ( ContextKeyExpr.and(( ContextKeyExpr.or(IsWindowsContext, IsLinuxContext)), ( ChatContextKeys.inQuickChat.negate()))),
                        primary: KeyMod$1.CtrlCmd | KeyCode.UpArrow,
                        weight: KeybindingWeight.EditorContrib,
                    },
                    {
                        when: ( ContextKeyExpr.and(ChatContextKeys.inChatSession, ChatContextKeys.inQuickChat)),
                        primary: KeyMod$1.CtrlCmd | KeyCode.DownArrow,
                        weight: KeybindingWeight.WorkbenchContrib,
                    }
                ]
            });
        }
        runEditorCommand(accessor, editor) {
            const editorUri = editor.getModel()?.uri;
            if (editorUri) {
                const widgetService = accessor.get(IChatWidgetService);
                widgetService.getWidgetByInputUri(editorUri)?.focusResponseItem();
            }
        }
    });
    registerAction2(class FocusMostRecentlyFocusedChatAction extends EditorAction2 {
        constructor() {
            super({
                id: 'workbench.chat.action.focusLastFocused',
                title: ( localize2(4625, 'Focus Last Focused Chat List Item')),
                precondition: ( ContextKeyExpr.and(ChatContextKeys.inChatInput)),
                category: CHAT_CATEGORY,
                keybinding: [
                    {
                        when: ( ContextKeyExpr.and(ChatContextKeys.inputCursorAtTop, ( ChatContextKeys.inQuickChat.negate()))),
                        primary: KeyMod$1.CtrlCmd | KeyCode.UpArrow | KeyMod$1.Shift,
                        weight: KeybindingWeight.EditorContrib + 1,
                    },
                    {
                        when: ( ContextKeyExpr.and(( ContextKeyExpr.or(IsWindowsContext, IsLinuxContext)), ( ChatContextKeys.inQuickChat.negate()))),
                        primary: KeyMod$1.CtrlCmd | KeyCode.UpArrow | KeyMod$1.Shift,
                        weight: KeybindingWeight.EditorContrib + 1,
                    },
                    {
                        when: ( ContextKeyExpr.and(ChatContextKeys.inChatSession, ChatContextKeys.inQuickChat)),
                        primary: KeyMod$1.CtrlCmd | KeyCode.DownArrow | KeyMod$1.Shift,
                        weight: KeybindingWeight.WorkbenchContrib + 1,
                    }
                ]
            });
        }
        runEditorCommand(accessor, editor) {
            const editorUri = editor.getModel()?.uri;
            if (editorUri) {
                const widgetService = accessor.get(IChatWidgetService);
                widgetService.getWidgetByInputUri(editorUri)?.focusResponseItem(true);
            }
        }
    });
    registerAction2(class FocusChatInputAction extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chat.focusInput',
                title: ( localize2(4626, "Focus Chat Input")),
                f1: false,
                keybinding: [
                    {
                        primary: KeyMod$1.CtrlCmd | KeyCode.DownArrow,
                        weight: KeybindingWeight.WorkbenchContrib,
                        when: ( ContextKeyExpr.and(ChatContextKeys.inChatSession, ( ChatContextKeys.inChatInput.negate()), ( ChatContextKeys.inQuickChat.negate()))),
                    },
                    {
                        when: ( ContextKeyExpr.and(ChatContextKeys.inChatSession, ( ChatContextKeys.inChatInput.negate()), ChatContextKeys.inQuickChat)),
                        primary: KeyMod$1.CtrlCmd | KeyCode.UpArrow,
                        weight: KeybindingWeight.WorkbenchContrib,
                    }
                ]
            });
        }
        run(accessor, ...args) {
            const widgetService = accessor.get(IChatWidgetService);
            widgetService.lastFocusedWidget?.focusInput();
        }
    });
    const nonEnterpriseCopilotUsers = ( ContextKeyExpr.and(ChatContextKeys.enabled, ( ContextKeyExpr.notEquals(
        `config.${defaultChat.completionsAdvancedSetting}.authProvider`,
        defaultChat.provider.enterprise.id
    ))));
    registerAction2(class extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chat.manageSettings',
                title: ( localize2(4627, "Manage Chat")),
                category: CHAT_CATEGORY,
                f1: true,
                precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(
                    ChatContextKeys.Entitlement.planFree,
                    ChatContextKeys.Entitlement.planPro,
                    ChatContextKeys.Entitlement.planProPlus
                )), nonEnterpriseCopilotUsers)),
                menu: {
                    id: MenuId.ChatTitleBarMenu,
                    group: 'y_manage',
                    order: 1,
                    when: nonEnterpriseCopilotUsers
                }
            });
        }
        async run(accessor) {
            const openerService = accessor.get(IOpenerService);
            openerService.open(( URI.parse(defaultChat.manageSettingsUrl)));
        }
    });
    registerAction2(class ShowExtensionsUsingCopilot extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chat.showExtensionsUsingCopilot',
                title: ( localize2(4628, "Show Extensions using Copilot")),
                f1: true,
                category: EXTENSIONS_CATEGORY,
                precondition: ChatContextKeys.enabled
            });
        }
        async run(accessor) {
            const extensionsWorkbenchService = accessor.get(IExtensionsWorkbenchService);
            extensionsWorkbenchService.openSearch(`@feature:${CopilotUsageExtensionFeatureId}`);
        }
    });
    registerAction2(class ConfigureCopilotCompletions extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chat.configureCodeCompletions',
                title: ( localize2(4629, "Configure Inline Suggestions...")),
                precondition: ( ContextKeyExpr.and(ChatContextKeys.Setup.installed, ( ChatContextKeys.Setup.disabled.negate()), ( ChatContextKeys.Setup.untrusted.negate()))),
                menu: {
                    id: MenuId.ChatTitleBarMenu,
                    group: 'f_completions',
                    order: 10,
                }
            });
        }
        async run(accessor) {
            const commandService = accessor.get(ICommandService);
            commandService.executeCommand(defaultChat.completionsMenuCommand);
        }
    });
    registerAction2(class ShowQuotaExceededDialogAction extends Action2 {
        constructor() {
            super({
                id: OPEN_CHAT_QUOTA_EXCEEDED_DIALOG,
                title: ( localize(4630, "Upgrade GitHub Copilot Plan"))
            });
        }
        async run(accessor) {
            const chatEntitlementService = accessor.get(IChatEntitlementService);
            const commandService = accessor.get(ICommandService);
            const dialogService = accessor.get(IDialogService);
            const telemetryService = accessor.get(ITelemetryService);
            let message;
            const chatQuotaExceeded = chatEntitlementService.quotas.chat?.percentRemaining === 0;
            const completionsQuotaExceeded = chatEntitlementService.quotas.completions?.percentRemaining === 0;
            if (chatQuotaExceeded && !completionsQuotaExceeded) {
                message = ( localize(
                    4631,
                    "You've reached your monthly chat messages quota. You still have free inline suggestions available."
                ));
            }
            else if (completionsQuotaExceeded && !chatQuotaExceeded) {
                message = ( localize(
                    4632,
                    "You've reached your monthly inline suggestions quota. You still have free chat messages available."
                ));
            }
            else {
                message = ( localize(
                    4633,
                    "You've reached your monthly chat messages and inline suggestions quota."
                ));
            }
            if (chatEntitlementService.quotas.resetDate) {
                const dateFormatter = chatEntitlementService.quotas.resetDateHasTime ? safeIntl.DateTimeFormat(language, { year: 'numeric', month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric' }) : safeIntl.DateTimeFormat(language, { year: 'numeric', month: 'long', day: 'numeric' });
                const quotaResetDate = ( new Date(chatEntitlementService.quotas.resetDate));
                message = [message, ( localize(
                    4634,
                    "The allowance will reset on {0}.",
                    dateFormatter.value.format(quotaResetDate)
                ))].join(' ');
            }
            const free = chatEntitlementService.entitlement === ChatEntitlement.Free;
            const upgradeToPro = free ? ( localize(
                4635,
                "Upgrade to GitHub Copilot Pro (your first 30 days are free) for:\n- Unlimited inline suggestions\n- Unlimited chat messages\n- Access to premium models"
            )) : undefined;
            await dialogService.prompt({
                type: 'none',
                message: ( localize(4636, "GitHub Copilot Quota Reached")),
                cancelButton: {
                    label: ( localize(4637, "Dismiss")),
                    run: () => { }
                },
                buttons: [
                    {
                        label: free ? ( localize(4638, "Upgrade to GitHub Copilot Pro")) : ( localize(4639, "Upgrade GitHub Copilot Plan")),
                        run: () => {
                            const commandId = 'workbench.action.chat.upgradePlan';
                            telemetryService.publicLog2('workbenchActionExecuted', { id: commandId, from: 'chat-dialog' });
                            commandService.executeCommand(commandId);
                        }
                    },
                ],
                custom: {
                    icon: Codicon.copilotWarningLarge,
                    markdownDetails: coalesce([
                        { markdown: ( new MarkdownString(message, true)) },
                        upgradeToPro ? { markdown: ( new MarkdownString(upgradeToPro, true)) } : undefined
                    ])
                }
            });
        }
    });
    registerAction2(class ResetTrustedToolsAction extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chat.resetTrustedTools',
                title: ( localize2(4640, "Reset Tool Confirmations")),
                category: CHAT_CATEGORY,
                f1: true,
                precondition: ChatContextKeys.enabled
            });
        }
        run(accessor) {
            accessor.get(ILanguageModelToolsConfirmationService).resetToolAutoConfirmation();
            accessor.get(INotificationService).info(( localize(4641, "Tool confirmation preferences have been reset.")));
        }
    });
    registerAction2(class UpdateInstructionsAction extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chat.generateInstructions',
                title: ( localize2(4642, "Generate Workspace Instructions File")),
                shortTitle: ( localize2(4643, "Generate Chat Instructions")),
                category: CHAT_CATEGORY,
                icon: Codicon.sparkle,
                f1: true,
                precondition: ChatContextKeys.enabled,
                menu: {
                    id: CHAT_CONFIG_MENU_ID,
                    when: ( ContextKeyExpr.and(ChatContextKeys.enabled, ( ContextKeyExpr.equals('view', ChatViewId)))),
                    order: 11,
                    group: '1_level'
                }
            });
        }
        async run(accessor) {
            const commandService = accessor.get(ICommandService);
            const query = `Analyze this codebase to generate or update \`.github/copilot-instructions.md\` for guiding AI coding agents.

Focus on discovering the essential knowledge that would help an AI agents be immediately productive in this codebase. Consider aspects like:
- The "big picture" architecture that requires reading multiple files to understand - major components, service boundaries, data flows, and the "why" behind structural decisions
- Critical developer workflows (builds, tests, debugging) especially commands that aren't obvious from file inspection alone
- Project-specific conventions and patterns that differ from common practices
- Integration points, external dependencies, and cross-component communication patterns

Source existing AI conventions from \`**/{.github/copilot-instructions.md,AGENT.md,AGENTS.md,CLAUDE.md,.cursorrules,.windsurfrules,.clinerules,.cursor/rules/**,.windsurf/rules/**,.clinerules/**,README.md}\` (do one glob search).

Guidelines (read more at https://aka.ms/vscode-instructions-docs):
- If \`.github/copilot-instructions.md\` exists, merge intelligently - preserve valuable content while updating outdated sections
- Write concise, actionable instructions (~20-50 lines) using markdown structure
- Include specific examples from the codebase when describing patterns
- Avoid generic advice ("write tests", "handle errors") - focus on THIS project's specific approaches
- Document only discoverable patterns, not aspirational practices
- Reference key files/directories that exemplify important patterns

Update \`.github/copilot-instructions.md\` for the user, then ask for feedback on any unclear or incomplete sections to iterate.`;
            await commandService.executeCommand('workbench.action.chat.open', {
                mode: 'agent',
                query: query,
            });
        }
    });
    registerAction2(class OpenChatFeatureSettingsAction extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chat.openFeatureSettings',
                title: ( localize2(4644, "Chat Settings")),
                shortTitle: ( localize(4645, "Chat Settings")),
                category: CHAT_CATEGORY,
                f1: true,
                precondition: ChatContextKeys.enabled,
                menu: [{
                        id: CHAT_CONFIG_MENU_ID,
                        when: ( ContextKeyExpr.and(ChatContextKeys.enabled, ( ContextKeyExpr.equals('view', ChatViewId)))),
                        order: 15,
                        group: '3_configure'
                    },
                    {
                        id: MenuId.ChatWelcomeContext,
                        group: '2_settings',
                        order: 1
                    }]
            });
        }
        async run(accessor) {
            const preferencesService = accessor.get(IPreferencesService);
            preferencesService.openSettings({ query: '@feature:chat ' });
        }
    });
    MenuRegistry.appendMenuItem(MenuId.ViewTitle, {
        submenu: CHAT_CONFIG_MENU_ID,
        title: ( localize2(4646, "Configure Chat")),
        group: 'navigation',
        when: ( ContextKeyExpr.equals('view', ChatViewId)),
        icon: Codicon.gear,
        order: 6
    });
}
function stringifyItem(item, includeName = true) {
    if (isRequestVM(item)) {
        return (includeName ? `${item.username}: ` : '') + item.messageText;
    }
    else {
        return (includeName ? `${item.username}: ` : '') + ( item.response.toString());
    }
}
const defaultChat = {
    manageSettingsUrl: product.defaultChatAgent?.manageSettingsUrl ?? '',
    provider: product.defaultChatAgent?.provider ?? { enterprise: { id: '' } },
    completionsAdvancedSetting: product.defaultChatAgent?.completionsAdvancedSetting ?? '',
    completionsMenuCommand: product.defaultChatAgent?.completionsMenuCommand ?? '',
};
MenuRegistry.appendMenuItem(MenuId.CommandCenter, {
    submenu: MenuId.ChatTitleBarMenu,
    title: ( localize(4647, "Chat")),
    icon: Codicon.chatSparkle,
    when: ( ContextKeyExpr.and(ChatContextKeys.supported, ( ContextKeyExpr.and(( ChatContextKeys.Setup.hidden.negate()), ( ChatContextKeys.Setup.disabled.negate()))), ( ContextKeyExpr.has('config.chat.commandCenter.enabled')))),
    order: 10001
});
MenuRegistry.appendMenuItem(MenuId.TitleBar, {
    submenu: MenuId.ChatTitleBarMenu,
    title: ( localize(4647, "Chat")),
    group: 'navigation',
    icon: Codicon.chatSparkle,
    when: ( ContextKeyExpr.and(ChatContextKeys.supported, ( ContextKeyExpr.and(( ChatContextKeys.Setup.hidden.negate()), ( ChatContextKeys.Setup.disabled.negate()))), ( ContextKeyExpr.has('config.chat.commandCenter.enabled')), ( ( ContextKeyExpr.has('config.window.commandCenter')).negate()))),
    order: 1
});
registerAction2(class ToggleCopilotControl extends ToggleTitleBarConfigAction {
    constructor() {
        super('chat.commandCenter.enabled', ( localize(4648, 'Chat Controls')), ( localize(4649, "Toggle visibility of the Chat Controls in title bar")), 5, ( ContextKeyExpr.and(( ContextKeyExpr.and(( ChatContextKeys.Setup.hidden.negate()), ( ChatContextKeys.Setup.disabled.negate()))), ( IsCompactTitleBarContext.negate()), ChatContextKeys.supported)));
    }
});
let CopilotTitleBarMenuRendering = class CopilotTitleBarMenuRendering extends Disposable {
    static { this.ID = 'workbench.contrib.copilotTitleBarMenuRendering'; }
    constructor(actionViewItemService, chatEntitlementService) {
        super();
        const disposable = actionViewItemService.register(MenuId.CommandCenter, MenuId.ChatTitleBarMenu, (action, options, instantiationService, windowId) => {
            if (!(action instanceof SubmenuItemAction)) {
                return undefined;
            }
            const dropdownAction = toAction({
                id: 'copilot.titleBarMenuRendering.more',
                label: ( localize(4650, "More...")),
                run() { }
            });
            const chatSentiment = chatEntitlementService.sentiment;
            const chatQuotaExceeded = chatEntitlementService.quotas.chat?.percentRemaining === 0;
            const signedOut = chatEntitlementService.entitlement === ChatEntitlement.Unknown;
            const anonymous = chatEntitlementService.anonymous;
            const free = chatEntitlementService.entitlement === ChatEntitlement.Free;
            const isAuxiliaryWindow = windowId !== mainWindow.vscodeWindowId;
            let primaryActionId = isAuxiliaryWindow ? CHAT_OPEN_ACTION_ID : TOGGLE_CHAT_ACTION_ID;
            let primaryActionTitle = isAuxiliaryWindow ? ( localize(4600, "Open Chat")) : ( localize(4602, "Toggle Chat"));
            let primaryActionIcon = Codicon.chatSparkle;
            if (chatSentiment.installed && !chatSentiment.disabled) {
                if (signedOut && !anonymous) {
                    primaryActionId = CHAT_SETUP_ACTION_ID;
                    primaryActionTitle = ( localize(4651, "Sign in to use AI features..."));
                    primaryActionIcon = Codicon.chatSparkleError;
                }
                else if (chatQuotaExceeded && free) {
                    primaryActionId = OPEN_CHAT_QUOTA_EXCEEDED_DIALOG;
                    primaryActionTitle = ( localize(
                        4652,
                        "GitHub Copilot Free plan chat messages quota reached. Click for details."
                    ));
                    primaryActionIcon = Codicon.chatSparkleWarning;
                }
            }
            return instantiationService.createInstance(DropdownWithPrimaryActionViewItem, instantiationService.createInstance(MenuItemAction, {
                id: primaryActionId,
                title: primaryActionTitle,
                icon: primaryActionIcon,
            }, undefined, undefined, undefined, undefined), dropdownAction, action.actions, '', { ...options, skipTelemetry: true });
        }, Event.any(chatEntitlementService.onDidChangeSentiment, chatEntitlementService.onDidChangeQuotaExceeded, chatEntitlementService.onDidChangeEntitlement, chatEntitlementService.onDidChangeAnonymous));
        markAsSingleton(disposable);
    }
};
CopilotTitleBarMenuRendering = ( __decorate([
    ( __param(0, IActionViewItemService)),
    ( __param(1, IChatEntitlementService))
], CopilotTitleBarMenuRendering));
async function handleCurrentEditingSession(model, phrase, dialogService) {
    return showClearEditingSessionConfirmation(model, dialogService, { messageOverride: phrase });
}
async function handleModeSwitch(accessor, fromMode, toMode, requestCount, model) {
    if (!model?.editingSession || fromMode === toMode) {
        return { needToClearSession: false };
    }
    const configurationService = accessor.get(IConfigurationService);
    const dialogService = accessor.get(IDialogService);
    const needToClearEdits = (!configurationService.getValue(ChatConfiguration.Edits2Enabled) && (fromMode === ChatModeKind.Edit || toMode === ChatModeKind.Edit)) && requestCount > 0;
    if (needToClearEdits) {
        const phrase = ( localize(4653, "Switching agents will end your current edit session."));
        const currentEdits = model.editingSession.entries.get();
        const undecidedEdits = currentEdits.filter((edit) => edit.state.get() === ModifiedFileEntryState.Modified);
        if (undecidedEdits.length > 0) {
            if (!(await handleCurrentEditingSession(model, phrase, dialogService))) {
                return false;
            }
            return { needToClearSession: true };
        }
        else {
            const confirmation = await dialogService.confirm({
                title: ( localize(4654, "Start new session?")),
                message: ( localize(
                    4655,
                    "Changing the agent will end your current edit session. Would you like to change the agent?"
                )),
                primaryButton: ( localize(4656, "Yes")),
                type: 'info'
            });
            if (!confirmation.confirmed) {
                return false;
            }
            return { needToClearSession: true };
        }
    }
    return { needToClearSession: false };
}
MenuRegistry.appendMenuItem(MenuId.EditorContext, {
    submenu: MenuId.ChatTextEditorMenu,
    group: '1_chat',
    order: 5,
    title: ( localize(4657, "Generate Code")),
    when: ( ContextKeyExpr.and(( ChatContextKeys.Setup.hidden.negate()), ( ChatContextKeys.Setup.disabled.negate())))
});
registerAction2(class ToggleDefaultVisibilityAction extends Action2 {
    constructor() {
        super({
            id: 'workbench.action.chat.toggleDefaultVisibility',
            title: ( localize2(4658, "Show View by Default")),
            toggled: ( ( ContextKeyExpr.equals('config.workbench.secondarySideBar.defaultVisibility', 'hidden')).negate()),
            f1: false,
            menu: {
                id: MenuId.ViewTitle,
                when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('view', ChatViewId)), ( ChatContextKeys.panelLocation.isEqualTo(ViewContainerLocation.AuxiliaryBar)))),
                order: 0,
                group: '5_configure'
            },
        });
    }
    async run(accessor) {
        const configurationService = accessor.get(IConfigurationService);
        const currentValue = configurationService.getValue('workbench.secondarySideBar.defaultVisibility');
        configurationService.updateValue('workbench.secondarySideBar.defaultVisibility', currentValue !== 'hidden' ? 'hidden' : 'visible');
    }
});
registerAction2(class EditToolApproval extends Action2 {
    constructor() {
        super({
            id: 'workbench.action.chat.editToolApproval',
            title: ( localize2(4659, "Manage Tool Approval")),
            metadata: {
                description: ( localize2(
                    4660,
                    "Edit/manage the tool approval and confirmation preferences for AI chat agents."
                )),
            },
            precondition: ChatContextKeys.enabled,
            f1: true,
            category: CHAT_CATEGORY,
        });
    }
    async run(accessor, scope) {
        const confirmationService = accessor.get(ILanguageModelToolsConfirmationService);
        const toolsService = accessor.get(ILanguageModelToolsService);
        confirmationService.manageConfirmationPreferences([...toolsService.getTools()], scope ? { defaultScope: scope } : undefined);
    }
});
registerAction2(class ToggleChatViewSessionsAction extends Action2 {
    constructor() {
        super({
            id: 'workbench.action.chat.toggleChatViewSessions',
            title: ( localize2(4661, "Show Sessions")),
            toggled: ( ContextKeyExpr.equals(`config.${ChatConfiguration.ChatViewSessionsEnabled}`, true)),
            menu: {
                id: MenuId.ChatWelcomeContext,
                group: '0_sessions',
                order: 1,
                when: ( ChatContextKeys.inChatEditor.negate())
            }
        });
    }
    async run(accessor) {
        const configurationService = accessor.get(IConfigurationService);
        const chatViewSessionsEnabled = configurationService.getValue(ChatConfiguration.ChatViewSessionsEnabled);
        await configurationService.updateValue(ChatConfiguration.ChatViewSessionsEnabled, !chatViewSessionsEnabled);
    }
});
const agentSessionsOrientationSubmenu = ( new MenuId('chatAgentSessionsOrientationSubmenu'));
MenuRegistry.appendMenuItem(MenuId.ChatWelcomeContext, {
    submenu: agentSessionsOrientationSubmenu,
    title: ( localize(4662, "Sessions Orientation")),
    group: '0_sessions',
    order: 2,
    when: ( ChatContextKeys.inChatEditor.negate())
});
registerAction2(class ToggleChatViewTitleAction extends Action2 {
    constructor() {
        super({
            id: 'workbench.action.chat.toggleChatViewTitle',
            title: ( localize2(4663, "Show Chat Title")),
            toggled: ( ContextKeyExpr.equals(`config.${ChatConfiguration.ChatViewTitleEnabled}`, true)),
            menu: {
                id: MenuId.ChatWelcomeContext,
                group: '1_modify',
                order: 2,
                when: ( ChatContextKeys.inChatEditor.negate())
            }
        });
    }
    async run(accessor) {
        const configurationService = accessor.get(IConfigurationService);
        const chatViewTitleEnabled = configurationService.getValue(ChatConfiguration.ChatViewTitleEnabled);
        await configurationService.updateValue(ChatConfiguration.ChatViewTitleEnabled, !chatViewTitleEnabled);
    }
});
registerAction2(class SetAgentSessionsOrientationAutoAction extends Action2 {
    constructor() {
        super({
            id: 'workbench.action.chat.setAgentSessionsOrientationAuto',
            title: ( localize2(4664, "Auto")),
            toggled: ( ContextKeyExpr.equals(`config.${ChatConfiguration.ChatViewSessionsOrientation}`, 'auto')),
            precondition: ( ContextKeyExpr.equals(`config.${ChatConfiguration.ChatViewSessionsEnabled}`, true)),
            menu: {
                id: agentSessionsOrientationSubmenu,
                group: 'navigation',
                order: 1
            }
        });
    }
    async run(accessor) {
        const configurationService = accessor.get(IConfigurationService);
        await configurationService.updateValue(ChatConfiguration.ChatViewSessionsOrientation, 'auto');
    }
});
registerAction2(class SetAgentSessionsOrientationStackedAction extends Action2 {
    constructor() {
        super({
            id: 'workbench.action.chat.setAgentSessionsOrientationStacked',
            title: ( localize2(4665, "Stacked")),
            toggled: ( ContextKeyExpr.equals(`config.${ChatConfiguration.ChatViewSessionsOrientation}`, 'stacked')),
            precondition: ( ContextKeyExpr.equals(`config.${ChatConfiguration.ChatViewSessionsEnabled}`, true)),
            menu: {
                id: agentSessionsOrientationSubmenu,
                group: 'navigation',
                order: 2
            }
        });
    }
    async run(accessor) {
        const configurationService = accessor.get(IConfigurationService);
        await configurationService.updateValue(ChatConfiguration.ChatViewSessionsOrientation, 'stacked');
    }
});
registerAction2(class SetAgentSessionsOrientationSideBySideAction extends Action2 {
    constructor() {
        super({
            id: 'workbench.action.chat.setAgentSessionsOrientationSideBySide',
            title: ( localize2(4666, "Side by Side")),
            toggled: ( ContextKeyExpr.equals(`config.${ChatConfiguration.ChatViewSessionsOrientation}`, 'sideBySide')),
            precondition: ( ContextKeyExpr.equals(`config.${ChatConfiguration.ChatViewSessionsEnabled}`, true)),
            menu: {
                id: agentSessionsOrientationSubmenu,
                group: 'navigation',
                order: 3
            }
        });
    }
    async run(accessor) {
        const configurationService = accessor.get(IConfigurationService);
        await configurationService.updateValue(ChatConfiguration.ChatViewSessionsOrientation, 'sideBySide');
    }
});
registerAction2(class ToggleChatViewWelcomeAction extends Action2 {
    constructor() {
        super({
            id: 'workbench.action.chat.toggleChatViewWelcome',
            title: ( localize2(4667, "Show Welcome")),
            category: CHAT_CATEGORY,
            precondition: ChatContextKeys.enabled,
            toggled: ( ContextKeyExpr.equals(`config.${ChatConfiguration.ChatViewWelcomeEnabled}`, true)),
            menu: {
                id: MenuId.ChatWelcomeContext,
                group: '1_modify',
                order: 3,
                when: ( ChatContextKeys.inChatEditor.negate())
            }
        });
    }
    async run(accessor) {
        const configurationService = accessor.get(IConfigurationService);
        const chatViewWelcomeEnabled = configurationService.getValue(ChatConfiguration.ChatViewWelcomeEnabled);
        await configurationService.updateValue(ChatConfiguration.ChatViewWelcomeEnabled, !chatViewWelcomeEnabled);
    }
});

export { ACTION_ID_NEW_CHAT, ACTION_ID_NEW_EDIT_SESSION, ACTION_ID_OPEN_CHAT, CHAT_CATEGORY, CHAT_CONFIG_MENU_ID, CHAT_OPEN_ACTION_ID, CHAT_SETUP_ACTION_ID, CHAT_SETUP_SUPPORT_ANONYMOUS_ACTION_ID, CopilotTitleBarMenuRendering, ModeOpenChatGlobalAction, getOpenChatActionIdForMode, handleCurrentEditingSession, handleModeSwitch, registerChatActions, stringifyItem };
